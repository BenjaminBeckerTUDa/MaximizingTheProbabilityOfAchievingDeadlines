#!/usr/bin/python
# ****************************************************************************
# *  Copyright: National ICT Australia,  2009 - 2010                         *
# *  Developed at the ATP lab, Networked Systems research theme              *
# *  Author(s): Yuriy Tselishchev                                            *
# *  This file is distributed under the terms in the attached LICENSE file.  *
# *  If you do not find this file, copies can be found by writing to:        *
# *                                                                          *
# *      NICTA, Locked Bag 9013, Alexandria, NSW 1435, Australia             *
# *      Attention:  License Inquiry.                                        *
# *                                                                          *
# ***************************************************************************/

import os, sys, commands, getopt, re
from optparse import OptionParser

styles = ["linespoints","histogram","rowstacked","columnstacked"]

parser = OptionParser(usage="usage: %prog [options]")
parser.add_option("-d","--debug", dest="debug", default=False, action="store_true", help="Debug mode, will display gnuplot commands as they are dispatched")
parser.add_option("-g","--greyscale", dest="grey", default=False, action="store_true", help="Use greyscale colors only")
parser.add_option("-l","--legend", dest="legend", type="string", default="", help="Set legend position (passed to gnuplot directly with 'set key')")
parser.add_option("-o","--output", dest="output", type="string", default="plot.ps", metavar="FILE", help="Select output file, default is 'plot.ps'")
parser.add_option("-s","--style", dest="style", type="string", default="linespoints", help="Plot style to be used, supported values: " + ", ".join(styles))
parser.add_option("--gnuplot", dest="gnuplot", type="string", default="gnuplot", help="Path to gnuplot executable, default is 'gnuplot'")
parser.add_option("--histogram-gap", dest="histgap", type="float", help="Set gap between histogram columns")
parser.add_option("--histogram-box", dest="boxwidth", type="float", default="0.9", help="Set boxwidth of histogram columns")
parser.add_option("--xrange", dest="xrange", type="string", metavar="[MIN:]MAX", help="Set range of x-axis")
parser.add_option("--yrange", dest="yrange", type="string", metavar="[MIN:]MAX", help="Set range of y-axis")
parser.add_option("--rotate", dest="rotate", type="int", help="Set xtics rotation, in degrees (e.g. 45)")
parser.add_option("--xtitle", dest="xtitle", type="string", help="Set title of x-axis, will be determined automatically by default")
parser.add_option("--ytitle", dest="ytitle", type="string", help="Set title of y-axis, not displayed by deafult")

lines = sys.stdin.readlines()

try:
	options,args = parser.parse_args()
except getopt.GetoptError, err:
	quit(str(err))

title = ""
fulltitle = ""
xtitle = ""
xlabels = []
labels = []
table = []
datasets = 0
ci = 0

def extract_common(llist):
	common = ""
	result = []
	for l in llist:
		l = l.strip().replace("\"","")
		if len(l) < 1: continue
		m = re.match(r"^([^\=]+)\=([^\=]+)$",l)
		if (m):
			if common == "":
				common = m.group(1)
			elif common != m.group(1):
				common = ""
				break
			result.append(m.group(2))
		else:
			break
	if common == "":
		result = []
		for l in llist:
			l = l.strip()
			if len(l) > 0:
				result.append(l)
	else:
		common = common.split(",")[-1]
	return result,common

for line in lines:
	m = re.match(r"[-+ \n]+$",line)
	if (m): continue
	data = line.strip().strip("|").split("|")
	if len(data) == 0: continue
	if len(data) == 1:
		if not title:
			fulltitle = data[0]
			title = data[0].split(":")[1]
		elif data[0] == fulltitle + " - confidence intervals":
			if options.style == "linespoints":
				ci = datasets
				xlabels = []
			else:
				quit("\nERROR: confidence intervals can only be plotted with linespoints style")
		else:
			quit("\nERROR: unable to plot this table or bad input syntax\n")
	elif title and not xlabels:
		xlabels,xtitle = extract_common(data)
	else:
		datasets += 1
		if len(data) > len(xlabels):
			labels.append(data.pop(0).strip())
		else:
			labels.append("row " + str(datasets))
		row = 0
		for d in data:
			if row >= len(table): table.append([])
			table[row].append(d.strip())
			row += 1

labels,ltitle = extract_common(labels)

if options.style == "rowstacked":
	tmp = ltitle;
	ltitle = xtitle;
	xtitle = tmp;

fname = "data" + str(os.getpid()) + ".dat"
fr = open(fname,"w")

def myprint(fr,line):
	if options.debug:
		print line
	print >>fr, line

if options.debug:
	print("\n===DEBUG: input data file===")

myprint(fr, "title \"" + "\" \"".join(labels) + "\"")
xtics_add = []
for x in range(len(xlabels)):
	if options.style != "rowstacked":
		xtics_add.append('"' + xlabels[x] + '" ' + str(x) + " 0") 
		myprint(fr, str(x) + " " + " ".join(table.pop(0)))
	else:
		myprint(fr, "\"" + xlabels[x] + "\" " + " ".join(table.pop(0)))
fr.close()

if options.style not in styles:
	quit("\nERROR: unknown style, supported values: " + ", ".join(styles))

name,ext = options.output.split(".")
if ext != 'ps' and ext != 'eps':
	name += ".ps"
else:
	name = options.output

if options.debug:
	print("\n===DEBUG: gnuplot commands===")	
f = os.popen(options.gnuplot,'w')
if options.grey:
	myprint(f, "set term postscript enhanced")
	myprint(f, "set palette grey")
else:
	myprint(f, "set term postscript enhanced color")
	
myprint(f, "set output \"" + name + "\"")
myprint(f, "set title \"" + title + "\"")

if options.xrange:
	if ":" in options.xrange: 
		rmin,rmax = options.xrange.split(":")
	else:
		rmin = "0"
		rmax = options.xrange
	myprint(f, "set xrange ["+rmin+":"+rmax+"]")
if options.yrange:
	if ":" in options.yrange: 
		rmin,rmax = options.yrange.split(":")
	else:
		rmin = "0"
		rmax = options.yrange
	myprint(f, "set yrange ["+rmin+":"+rmax+"]")
	
if options.rotate: myprint(f, "set xtics nomirror rotate by -" + str(options.rotate) + " (" + ', '.join(xtics_add) + ")")
else: myprint(f, "set xtics (" + ', '.join(xtics_add) + ")")
key = "set key "
if ltitle != "": key += "title \"" + ltitle + "\" "
if ltitle != "" or options.legend: myprint(f, key + options.legend)
if options.xtitle: myprint(f, "set xlabel '" + options.xtitle + "'")
elif xtitle != "": myprint(f, "set xlabel '" + xtitle + "'")
if options.ytitle: myprint(f, "set ylabel '" + options.ytitle + "'")

if options.style == "linespoints":
	myprint(f, "set style data linespoints")
else:
	myprint(f, "set style data histogram")
	if options.style == "histogram":
		if options.histgap:
			myprint(f, "set style histogram cluster gap " + str(options.histgap))
		elif len(labels) > 1:
			myprint(f, "set style histogram cluster gap 1")
		else:
			myprint(f, "set style histogram cluster gap 0")
	elif options.style == "rowstacked":
		myprint(f, "set style histogram columnstacked")
	elif options.style == "columnstacked":
		myprint(f, "set style histogram rowstacked")
	if options.grey:
		myprint(f, "set style fill pattern border -1")
	else:
		myprint(f, "set style fill solid 0.5 noborder")
	myprint(f, "set boxwidth " + str(options.boxwidth))

plots = []
plots_ci = []
if options.style == "rowstacked":
	for i in range(0,len(labels)):
		if i == 0: plots.append("using " + str(i+2) + ":key(1) title col")
		else: plots.append("using " + str(i+2) + " title col")
else:
	for i in range(0,len(labels)):
		if options.style == "linespoints":
			if ci != 0 and i >= ci:
				plots_ci.append("using 1:" + str(i-ci+2) + ":" + str(i+2) + " notitle with yerrorbars")
			else:
				plots.append("using 1:" + str(i+2) + " title col")
		else:
			plots.append("using " + str(i+2) + " title col")	

if len(plots_ci):
	myprint(f, "set multiplot")
	if not options.yrange: myprint(f, "set yrange [] writeback")
	myprint(f, "plot './" + fname + "' " + ", '' ".join(plots))
	myprint(f, "unset key")
	if not options.yrange: myprint(f, "set yrange restore")
	myprint(f, "plot './" + fname + "' " + ", '' ".join(plots_ci))
	myprint(f, "unset multiplot")
else:
	myprint(f, "plot './" + fname + "' " + ", '' ".join(plots))

f.flush()
f.close()

if name != options.output:
	r = commands.getoutput("convert -rotate 90 " + name + " " + options.output + " 2>&1")
	commands.getoutput("rm " + name)	
else:
	r = ""

commands.getoutput("rm " + fname)
if r and r != "":
	quit("\nERROR:\n" + r)
	


