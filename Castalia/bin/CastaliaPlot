#!/usr/bin/python
# ****************************************************************************
# *  Copyright: National ICT Australia,  2009 - 2010                         *
# *  Developed at the ATP lab, Networked Systems research theme              *
# *  Author(s): Yuriy Tselishchev                                            *
# *  This file is distributed under the terms in the attached LICENSE file.  *
# *  If you do not find this file, copies can be found by writing to:        *
# *                                                                          *
# *      NICTA, Locked Bag 9013, Alexandria, NSW 1435, Australia             *
# *      Attention:  License Inquiry.                                        *
# *                                                                          *
# ***************************************************************************/

import os, sys, commands, getopt, re
from optparse import OptionParser

styles = ["linespoints","histogram","rowstacked"]

parser = OptionParser(usage="usage: %prog [options]")
parser.add_option("-d","--debug", dest="debug", default=False, action="store_true", help="Debug mode, will display gnuplot commands as they are dispatched")
parser.add_option("-l","--legend", dest="legend", type="string", default="", help="Set legend position (passed to gnuplot directly with 'set key')")
parser.add_option("-o","--output", dest="output", type="string", default="plot.ps", metavar="FILE", help="Select output file, default is 'plot.ps'")
parser.add_option("-s","--style", dest="style", type="string", default="linespoints", help="Plot style to be used, supported values: " + ", ".join(styles))
parser.add_option("--gnuplot", dest="gnuplot", type="string", default="gnuplot", help="Path to gnuplot executable, default is 'gnuplot'")
parser.add_option("--xtics", dest="xtics", type="string", help="Set xtics (passed to gnuplot directly with 'set xtics')")
parser.add_option("--xtitle", dest="xtitle", type="string", help="Set title of x-axis, will be determined automatically by default")
parser.add_option("--ytitle", dest="ytitle", type="string", help="Set title of y-axis, not displayed by deafult")
(options,args) = parser.parse_args()

lines = sys.stdin.readlines()
title = ""
xtitle = ""
xlabels = []
labels = []
table = []
datasets = 0
longlabels = 0

def extract_common(llist):
	common = ""
	result = []
	for l in llist:
		l = l.strip().replace("\"","")
		if len(l) < 1: continue
		m = re.match(r"^([^\=]+)\=([^\=]+)$",l)
		if (m):
			if common == "":
				common = m.group(1)
			elif common != m.group(1):
				common = ""
				break
			result.append(m.group(2))
		else:
			break
	if common == "":
		result = []
		for l in llist:
			l = l.strip()
			if len(l) > 0:
				result.append(l)
	return result,common

for line in lines:
	m = re.match(r"[-+ \n]+$",line)
	if (m): continue
	data = line.strip().strip("|").split("|")
	if len(data) == 0: continue
	if len(data) == 1:
		if not title:
			title = data[0].split(":")[1]
		else:
			quit("\nERROR: unable to plot this table or bad input syntax\n")
	elif title and not xlabels:
		xlabels,xtitle = extract_common(data)
	else:
		datasets += 1
		if len(data) > len(xlabels):
			labels.append(data.pop(0).strip())
		else:
			labels.append("row " + str(datasets))
		row = 0
		for d in data:
			if row >= len(table): table.append([])
			table[row].append(d.strip())
			row += 1

labels,ltitle = extract_common(labels)

fname = "data" + str(os.getpid()) + ".dat"
fr = open(fname,"w")

def myprint(fr,line):
	if options.debug:
		print line
	print >>fr, line

if options.debug:
	print("\n===DEBUG: input data file===")
if options.style == 'rowstacked':
	myprint(fr, "title \"" + "\" \"".join(xlabels) + "\"")
	while len(labels) > 0:
		if len(labels[0]) > 5: longlabels = 1
		line = "\"" + labels.pop(0) + "\""
		for d in table:
			line += " " + d[len(d) - len(labels) - 1]
		myprint(fr, line)
	fr.close()
	tmp = xtitle
	xtitle = ltitle
	ltitle = tmp
else:
	myprint(fr, "title \"" + "\" \"".join(labels) + "\"")
	while len(xlabels) > 0:
		if len(xlabels[0]) > 5: longlabels = 1
		myprint(fr, "\"" + xlabels.pop(0) + "\" " + " ".join(table.pop(0)))
	fr.close()

if options.style not in styles:
	quit("\nERROR: unknown style, supported values: " + ", ".join(styles))

name,ext = options.output.split(".")
if ext != 'ps' and ext != 'eps':
	name += ".ps"
else:
	name = options.output

if options.debug:
	print("\n===DEBUG: gnuplot commands===")	
f = os.popen(options.gnuplot,'w')
myprint(f, "set term postscript enhanced color")
myprint(f, "set output \"" + name + "\"")
myprint(f, "set title \"" + title + "\"")
if options.xtics: myprint(f, "set xtics " + options.xtics)
elif longlabels: myprint(f, "set xtics nomirror rotate by -45")
key = "set key "
if ltitle != "": key += "title \"" + ltitle + "\" "
if ltitle != "" or options.legend: myprint(f, key + options.legend)
if options.xtitle: myprint(f, "set xlabel '" + options.xtitle + "'")
elif xtitle != "": myprint(f, "set xlabel '" + xtitle + "'")
if options.ytitle: myprint(f, "set ylabel '" + options.ytitle + "'")

if options.style == "linespoints":
	myprint(f, "set style data linespoints")
	plotcmd = "plot './" + fname + "' using 2:xtic(1) ti col"
	i = 2
	while i <= len(labels):
		i += 1
		plotcmd += ", '' u " + str(i) + " ti col"
	myprint(f, plotcmd)
elif options.style == "histogram":
	myprint(f, "set style data histogram")
	myprint(f, "set style histogram cluster gap 1")
	myprint(f, "set style fill solid border -1")
	plotcmd = "plot './" + fname + "' using 2:xtic(1) ti col"
	i = 2
	while i <= len(labels):
		i += 1
		plotcmd += ", '' u " + str(i) + " ti col"
	myprint(f, plotcmd)
elif options.style == "rowstacked":
	myprint(f, "set style data histogram")
	myprint(f, "set style histogram rowstacked")
	myprint(f, "set style fill solid border -1")
	plotcmd = "plot './" + fname + "' using 2:xtic(1) ti col"
	i = 2
	while i <= len(xlabels):
		i += 1
		plotcmd += ", '' u " + str(i) + " ti col"
	myprint(f, plotcmd)

f.flush()
f.close()

if name != options.output:
	r = commands.getoutput("convert -rotate 90 " + name + " " + options.output + " 2>&1")
	commands.getoutput("rm " + name)	
else:
	r = ""

commands.getoutput("rm " + fname)
if r and r != "":
	quit("\nERROR:\n" + r)
	


