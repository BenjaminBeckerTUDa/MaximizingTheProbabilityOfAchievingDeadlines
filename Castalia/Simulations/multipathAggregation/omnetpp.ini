# ***************************************************************************************
# *  Copyright: National ICT Australia,  2006											*
# *  Developed at the Networks and Pervasive Computing program							*
# *  Author(s): Athanassios Boulis, Dimosthenis Pediaditakis							*
# *  This file is distributed under the terms in the attached LICENSE file.				*
# *  If you do not find this file, copies can be found by writing to:					*
# *																						*
# *      NICTA, Locked Bag 9013, Alexandria, NSW 1435, Australia						*
# *      Attention:  License Inquiry.													*
# *																						*
# **************************************************************************************/



#omnetpp.ini for SN-simulator

[General]
preload-ned-files = *.ned @../../nedfiles.lst

network = SN  # this line is for Cmdenv, Tkenv will still let you choose from a dialog
output-vector-file = SN-stats.vec
output-scalar-file = SN-stats.sca
debug-on-errors = true

num-rngs = 9				# 8 random number streams (or generators as OMNeT calls them)
					# the first one is used in the ned file

seed-0-mt = 10				# the seeds for each of the RNGs
seed-1-mt = 20
seed-2-mt = 30
seed-3-mt = 40
seed-4-mt = 50
seed-5-mt = 60
seed-6-mt = 70
seed-7-mt = 80
seed-8-mt = 90


SN.wirelessChannel.rng-0 = 1		# wireless channel has 2 rngs. The first one is associated
SN.wirelessChannel.rng-1 = 2		# with the second physical stream (#1) and the second with the third (#2) 
#SN.physicalProcess[*].rng-0  = 3	# temperature has only 1 rng. It is associated with stream #3 
SN.node[*].nodeApplication.rng-0	 = 3		# Randomizes the start time of the application 
SN.node[*].networkInterface.MAC.rng-0	 = 4		# Produces values compared against txProb
SN.node[*].networkInterface.MAC.rng-1	 = 5		# Produces values between [0 ....  randomTxOffset]
SN.node[*].nodeResourceMgr.rng-0	 = 6		# Produces values of the clock drift of the CPU of each node
SN.node[*].nodeSensorDevMgr.rng-0	 = 7		# Produces values of the sensor devices' bias
SN.node[*].nodeSensorDevMgr.rng-1	 = 8		# Produces values of the sensor devices' noise


sim-time-limit = 4s



[Cmdenv]
#for non-express mode
express-mode = yes
module-messages = no
event-banners = no		# "yes" outputs all events in the screen
#status-frequency = 50
performance display = no
#Add more here!!




[Parameters]

#COMPOUND MODULE: SN (the network)
SN.field_x = 30				# meters
SN.field_y = 30				# meters
SN.numNodes = 16
SN.numPhysicalProcesses = 1
SN.deploymentType = 1			# 1 means a grid deployment
					# 2 means randomized grid deployment (i.e. grid + noise)
					# any other number is the default (uniform random) 



#SIMPLE SUB-MODULE of SN: wirelessChannel
SN.wirelessChannel.printStatistics = true
SN.wirelessChannel.pathLossExponent = 4
SN.wirelessChannel.sigma = 4
SN.wirelessChannel.noiseFloor = -105	# dBm  (-115 for mica motes, -??? for telos motes)
SN.wirelessChannel.PLd0 = 55		# dBm  the Path Loss at d0, should be a positive value
SN.wirelessChannel.d0 = 1		# meters
#SN.wirelessChannel.thresholdProb = 0.1
SN.wirelessChannel.collisionModel = 2	# 0 --> No Collisions
					# 1 --> Simple Collision Model (more than one transmissions heard by a receiver, leads to a collision)
					# 2 --> Additive interference model (transmissions seen as interference)
					# 3 --> Complex interference model (as above (2) but multiple transissions do not add-up linearly)
SN.wirelessChannel.rxSignal_ConnectivityMap = "" # example : "3->4(0)=-90, 4->3(3)=-92, 5->6=-78"
SN.wirelessChannel.PRR_ConnectivityMap = "" # example: "<24>, 14->15(0)=0.10, 4->3(3)=0.67, 5->6=0.20"




#SIMPLE SUB-MODULE of SN: physicalProcess[0]
SN.physicalProcess[0].inputType = 0  #  0 --> values are dictated by "directNodeValueAssignment" parameter
				     #  1 --> values are generated by the additive diffused sources scenario group of parameters
				     #  2 --> values read by the tracefile  (not yet ipmlemented)

SN.physicalProcess[0].directNodeValueAssignment = "(0) 7:40"  #Statically assign values to specific nodes.  
							      # Syntax explanantion : "(default_value) nodeID_A:value_A nodeID_B:val_B ... etc"
							      # If some nodes are not mentioned/defined then they get the default_value.
#Group of additive diffused sources scenario parameters
SN.physicalProcess[0].multiplicative_k = 0.25	# multiplicative parameter (k)
SN.physicalProcess[0].attenuation_exp_a = 1	# attenuation exponent (a)
SN.physicalProcess[0].sigma = 0.2		# standart deviation to the zero-mean additive gaussian noise (sigma)
SN.physicalProcess[0].max_num_snapshots = 10	# the maximum number of descrete states/snapshots that can be specified in source_X params below
SN.physicalProcess[0].numSources = 1	# number of differemt temperature sources, currently only up to 5 sources are supported
SN.physicalProcess[0].source_0 = "0 10 10 30.5; 5 10 10 45; 12 10 10 7.3"	# string showing how sources evolve over time (change in location and value)
SN.physicalProcess[0].source_1 = ""
SN.physicalProcess[0].source_2 = ""
SN.physicalProcess[0].source_3 = ""
SN.physicalProcess[0].source_4 = ""
#end of Group of additive diffused sources scenario parameters

SN.physicalProcess[0].tracefileName = ""

SN.physicalProcess[0].description = "Fire"





# ----------------------------------------------------------
# ---------  COMPOUND SUB-MODULES of SN: node[]  ------------
# ----------------------------------------------------------



# SIMPLE SUB-MODULE of node: nodeResourceMgr
SN.node[*].nodeResourceMgr.initialEnergy = 10		# joules
SN.node[*].nodeResourceMgr.sigmaCPUClockDrift = 0.0001
SN.node[*].nodeResourceMgr.ramSize = -1
SN.node[*].nodeResourceMgr.flashSize = -1
SN.node[*].nodeResourceMgr.flashWriteCost = -1
SN.node[*].nodeResourceMgr.flashReadCost = -1
SN.node[*].nodeResourceMgr.imageSize = -1
SN.node[*].nodeResourceMgr.cpuPowerSpeedLevelNames = ""
SN.node[*].nodeResourceMgr.cpuPowerPerLevel = ""
SN.node[*].nodeResourceMgr.cpuSpeedPerLevel = ""
SN.node[*].nodeResourceMgr.cpuInitialPowerLevel = -1



# SIMPLE SUB-MODULE of node: nodeSensorDevMgr 
SN.node[*].nodeSensorDevMgr.numSensingDevices = 1
SN.node[*].nodeSensorDevMgr.pwrConsumptionPerDevice = "0.02"  # in mW
SN.node[*].nodeSensorDevMgr.sensorTypes = "Temperature"
SN.node[*].nodeSensorDevMgr.corrPhyProcess = "0" 	#string-array that holds the index of the Physical process that each one of the sensors monitors
SN.node[*].nodeSensorDevMgr.maxSampleRates = "1"	# 1 sample per sec
SN.node[*].nodeSensorDevMgr.devicesBias = "0.1" 		#the sigmas (may be more than one as the variable is an array) of the bias of each one of the sensors
SN.node[*].nodeSensorDevMgr.devicesDrift = ""		
SN.node[*].nodeSensorDevMgr.devicesNoise = "0.1"		#the sigmas of the noise of each one of the sensors
SN.node[*].nodeSensorDevMgr.devicesHysterisis = ""



# SIMPLE SUB-MODULE of node: nodeApplication 
SN.node[*].appModuleName = "multipathAggregation_ApplicationModule"
SN.node[*].nodeApplication.priority = 1
SN.node[*].nodeApplication.maxAppPacketSize = 30
SN.node[*].nodeApplication.packetHeaderOverhead = 5
SN.node[*].nodeApplication.sinkID = 1  #the ID of the node that acts as a sink
SN.node[*].nodeApplication.epoch = 1   #in seconds
SN.node[*].nodeApplication.initPhaseDuration = 1 #in seconds



# *********************************************
# COMPOUND SUB-MODULE of Node: networkInterface 
# *********************************************


# SIMPLE SUB-MODULE of networkInterface: networkInterface.Radio
SN.node[*].networkInterface.Radio.printDroppedStatistics = true
SN.node[*].networkInterface.Radio.printStateTransitions = false #if true, the user must have specified in section [Cmdenv] "express-mode = no" in order the messages to get printed out
SN.node[*].networkInterface.Radio.dataRate = 250		# kbps   250kbps for Telos motes   and 19.2kbps for MICA motes
SN.node[*].networkInterface.Radio.noiseBandwidth = 500	# in KHz (mica motes = 30, telos motes = 500)
SN.node[*].networkInterface.Radio.modulationType = 1	# 0 --> FSK (noncoherent) -- for mica motes
							# 1 --> BPSK, QPSK, OQPSK -- for CC2420 (Telos motes)
SN.node[*].networkInterface.Radio.encodingType = 0	# 0 --> NRZ (only NRZ is currently implemented)
							# 1 --> 4B5B (future work, not yet implemented)
							# 2 --> Manchester (future work, not yet implemented)
							# 3 --> SECDEC (future work, not yet implemented)
SN.node[*].networkInterface.Radio.receiverSensitivity = -94	# in dBm  a)-98 for MICA2  b)-94 for TELOS
SN.node[*].networkInterface.Radio.rxPower = 62.04    	# mW
SN.node[*].networkInterface.Radio.listenPower = 62.04	# mW
SN.node[*].networkInterface.Radio.sleepPower = 1.4058		# mW
SN.node[*].networkInterface.Radio.txPowerLevels = "0 -1 -3 -5 -7 -10 -15 -25"	# in dBm, first element is the default level
										# max num of levels allowed = 15
SN.node[*].networkInterface.Radio.txPowerConsumptionPerLevel = "57.42 55.18 50.69 46.2 42.24 36.3 32.67 29.04"  # power consumption per TX level in mW
SN.node[*].networkInterface.Radio.txPowerLevelUsed = 0	# 0 - .... - N  [index referring to array txPowerLevels if defined outside txPowerLevels limits gets default value 0.]
SN.node[*].networkInterface.Radio.txModeUsed = 0		# a)0 for CARRIER_SENSE_NONE , b) 1 for CARRIER_SENSE_ONCE_CHECK, c)2 for CARRIER_SENSE_PERSISTENT
SN.node[*].networkInterface.Radio.bufferSize = 5		# number of MAC frames
SN.node[*].networkInterface.Radio.maxPhyFrameSize = 50	# in bytes
SN.node[*].networkInterface.Radio.phyFrameOverhead = 6	# in bytes
SN.node[*].networkInterface.Radio.delaySleep2Listen = 0.05  #in ms
SN.node[*].networkInterface.Radio.delayListen2Sleep = 0.02  #in ms
SN.node[*].networkInterface.Radio.delayTx2Sleep = 0.02	 #in ms
SN.node[*].networkInterface.Radio.delaySleep2Tx = 0.05	 #in ms
SN.node[*].networkInterface.Radio.delayListen2Tx = 0.01	 #in ms
SN.node[*].networkInterface.Radio.delayTx2Listen = 0.01	 #in ms
SN.node[*].networkInterface.Radio.delayCSValid = 0.128	 #in ms


# SIMPLE SUB-MODULE of networkInterface: networkInterface.MAC
SN.node[*].networkInterface.macModuleName = "TunableMacModule"
SN.node[*].networkInterface.MAC.printDroppedStatistics = true
SN.node[*].networkInterface.MAC.printStateTransitions = false  #if true, the user must have specified in section [Cmdenv] "express-mode = yes" in order the messages to get printed out
# ------ These are the parameters you can play with -----------------------------
SN.node[*].networkInterface.MAC.dutyCycle = 0.05		# listening / (sleeping+listening)
SN.node[*].networkInterface.MAC.listenInterval = 4	# ms, cannot be smaller than 0.5ms
SN.node[*].networkInterface.MAC.beaconIntervalFraction = 0.80  # beacon_interval / sleeping_interval, if 0 no beacons are sent
SN.node[*].networkInterface.MAC.probTx = 1		# the probability of a single try of Transmission to happen
SN.node[*].networkInterface.MAC.numTx = 1			# when we have something to Tx, how many times we try
SN.node[*].networkInterface.MAC.randomTxOffset = 10	# ms, Tx after time chosen randomly from interval [0..randomTxOffset]
SN.node[*].networkInterface.MAC.reTxInterval = 100	# ms, Interval between retransmissions, (numTx-1) retransmissions
SN.node[*].networkInterface.MAC.backoffType =  1 # 0-->(backoff = sleepinterval), 1-->(backoff = constant value), 2-->(backoff = multiplying value - e.g. 1*a, 2*a, 3*a, 4*a ...), 3-->(backoff = exponential value - e.g. 2, 4, 8, 16, 32...)
SN.node[*].networkInterface.MAC.backoffBaseValue = 20  #in ms
# ------ These are the parameters you can play with -- END ---------------------------
SN.node[*].networkInterface.MAC.maxMACFrameSize = 40	# bytes
SN.node[*].networkInterface.MAC.macFrameOverhead = 5	# bytes
SN.node[*].networkInterface.MAC.beaconFrameSize = 7	# bytes
SN.node[*].networkInterface.MAC.ACKFrameSize = 5		# bytes
SN.node[*].networkInterface.MAC.macBufferSize = 32	#number of messages so that occupy ~ 1MB
SN.node[*].networkInterface.MAC.carrierSense = true



[Run 1]
description = "first run"
SN.field_x = 50
SN.field_y = 50
SN.numNodes = 36