#!/usr/bin/perl	

use strict;

use Getopt::Long;

use constant WC_IDEAL => "../Parameters/WirelessChannel/Ideal.ini";
use constant WC_REAL => "../Parameters/WirelessChannel/Realistic.ini";
use constant R_IDEAL => "../Parameters/Radio/CC2420_IDEALmodulation.ini";
use constant R_REAL => "../Parameters/Radio/CC2420.ini";
use constant MAC_TUNABLE => "./MAC_Tunable.ini";
use constant MAC_TMAC => "../Parameters/MAC/TMAC.ini";
use constant MAC_SMAC => "../Parameters/MAC/SMAC.ini";
use constant ROUTING_MP => "../Parameters/Routing/MultipathRings.ini";
use constant ROUTING_ST => "../Parameters/Routing/SimpleTree.ini";
use constant ROUTING_BP => "../Parameters/Routing/Bypass.ini";

use constant Z_CONFIDENCE => 1.96;

my $stat = {};
my $conf = {
    "40x10" => { x => 40, y => 10 },
    "100x20" => { x => 100, y => 20 },
    "200x20" => { x => 200, y => 20 },
    "500x20" => { x => 500, y => 20 },
    "1000x20" => { x => 1000, y => 20 },
};

my $sim;
my $n;
my $ideal;
my $time;
my $print_result;
my $duty_cycle;
my $listen;
my $help;
my $alg;
my $sample;

GetOptions("n=i" => \$n, "sim=s" => \$sim, "ideal" => \$ideal, "time=i" => \$time, 
    "algorithm=i" => \$alg, "raw" => \$print_result, "duty=f" => \$duty_cycle,
    "listen=i" => \$listen, "help" => \$help, "physical=i" => \$sample);
    
if ($help) {
    print "
bridgeTestRun has the following options:
    -n			number of simulations to preform (the results are averaged), default is 1
    -s, --sim 		simulation topology to use, avaliable values are ".join(",", keys %$conf).", default is 40x10
    -i, --ideal		use ideal wireless channel, default is realistic
    -t, --time		run each simulation for this duration (in seconds), default is 600
    -r, --raw		print out raw results from each simulation, only averaged results are printed by default
    -p, --physical	rate of physical process sampling, in ms (default is 100ms or 10hz)
    -h, --help		print this message

    -a, --algorithm	communication stack to use, supported values are:
			1 - Tunable MAC with simple tree routing (default)
			2 - Tunable MAC with multipath rings routing
			3 - Tunable MAC with broadcasts (no routing)
			4 - TMAC with simple tree routing
			5 - TMAC with broadcasts (no routing)
			6 - SMAC with simple tree routing
			7 - SMAC with broadcasts (no routing)
			any other value defaults to 1
			NOTE that multipath rings uses broadcast packets only, so it is not compatible with TMAC

    These optios are supported only for Tunable MAC (algorithms 1-3):
    -l, --listen 	specify the listening time manually, default is 100*duty cycle 
    -d, --duty		use a specific duty cycle, values from 0 to 1, default is 1 
";
    exit(0);
}

$sim = $conf->{$sim} || $conf->{"40x10"};
$n = 1 unless $n > 1;
$time = 600 unless $time && $time > 0;
$sample = 100 unless $sample && $sample > 0;
$duty_cycle = 1 unless $duty_cycle > 0 and $duty_cycle < 1;
$listen = 100 * $duty_cycle unless $listen > 0;
$alg = 1 unless $alg && $alg > 0 && $alg < 8;
my $tmac = ($alg == 4 || $alg == 5);
my $smac = ($alg == 6 || $alg == 7);
my $broadcast = ($alg == 3 || $alg == 5 || $alg == 7);

my $ini = "

[General]

include ../Parameters/Castalia.ini

sim-time-limit = ".$time."s

include ../Parameters/SensorDevice/Accelerometer.ini
include ".($ideal ? WC_IDEAL : WC_REAL)."
include ".($ideal ? R_IDEAL : R_REAL)."
include ".($tmac ? MAC_TMAC : ($smac ? MAC_SMAC : MAC_TUNABLE))."
include ".($broadcast ? ROUTING_BP : ($alg == 2 ? ROUTING_MP : ROUTING_ST))."
".(!$tmac && !$smac ? "
SN.node[*].networkInterface.MAC.dutyCycle = $duty_cycle
SN.node[*].networkInterface.MAC.listenInterval = $listen
" : "")."

SN.node[*].appModuleName = \"BridgeTest_ApplicationModule\"
SN.node[*].nodeApplication.applicationID = \"bridgeTest\"
SN.node[*].nodeApplication.printDebugInfo = false
SN.node[*].nodeApplication.priority = 1

SN.node[*].nodeApplication.maxAppPacketSize = 70    #in bytes
SN.node[*].nodeApplication.packetHeaderOverhead = 8 #in bytes

SN.node[*].nodeApplication.reportTreshold = 10
SN.node[*].nodeApplication.sampleInterval = $sample
SN.node[*].nodeApplication.broadcastReports = ".($broadcast ? "true" : "false")."

SN.physicalProcessModuleName = \"CarsPhysicalProcess\"
SN.physicalProcess[0].printDebugInfo = false
SN.physicalProcess[0].description = \"Cars\"
SN.physicalProcess[0].max_num_cars = 5
SN.physicalProcess[0].car_speed = 16
SN.physicalProcess[0].car_value = 30
SN.physicalProcess[0].car_interarrival = 20

SN.physicalProcess[0].point1_x_coord = 0
SN.physicalProcess[0].point1_y_coord = ".($sim->{y}/2)."
SN.physicalProcess[0].point2_x_coord = ".$sim->{x}."
SN.physicalProcess[0].point2_y_coord = ".($sim->{y}/2)."

SN.field_x = $sim->{x}
SN.field_y = $sim->{y}
";

my $num = 1; 
my $tmp = "";

for (my $x = 0; $x <= $sim->{x}; $x+=20) {
    for (my $y = 0; $y <= $sim->{y}; $y+=10) {
	$tmp .= "
SN.node[$num].xCoor = $x
SN.node[$num].yCoor = $y
SN.node[$num].nodeApplication.isSink = false
";
	$num++;
    }
}

$ini .= "
SN.numNodes = $num
SN.deploymentType = 3

SN.node[0].xCoor = ".($sim->{x}/2)."
SN.node[0].yCoor = ".($sim->{y}/2)."
SN.node[0].nodeApplication.isSink = true
$tmp

repeat = $n

";

open INI, ">omnetpp.ini" || die "Unable to write omnetpp.ini";
print INI $ini;
close INI;

my $result = `../../CastaliaBin`;
my @lines = split /\n/, $result;
my $run = 0;

#print $result;
my $sink_res;
my $node_res;
my $simlen;
my $total_version_packets = 0;
my $curr_run = 0;
my $max_energy = 0;
my $avg_energy = 0;
my $node_num = 0;

for my $line (@lines) {
    if ($line =~ /Calling finish\(\) at end of Run \#(\d+)/) {
	$curr_run = $1;
    } elsif ($line =~ /Sink is at version: (\d+) packet: (\d+) total: (\d+)/) {
	$total_version_packets = ($1-1)*$3+$2;
    } elsif ($line =~ /Sink received from:/) { 
	$sink_res = 1; $node_res = 0;
    } elsif ($line =~ /Node (\d+) received version information:/) {
	$node_res = $1; $sink_res = 0;
    } elsif ($line =~ /^(\d+)\s(\d+)$/) {
	if ($sink_res) {
	    add_stat("Node $1 reports received", "$curr_run:$1", $2, 0);
	    add_stat("Overall reception", "$curr_run", $2, 0);
	} elsif ($node_res) {
	    add_stat("Version reception", "$curr_run:$node_res", $2, 0);
	    add_stat("Version reception", "$curr_run:$node_res", $total_version_packets, 1);
	}
    } elsif ($line =~ /^Node (\d+) sent (\d+) packets/) {
	add_stat("Node $1 reports received", "$curr_run:$1", $2, 1);
	add_stat("Overall reception", "$curr_run", $2, 1);
    } elsif ($line =~ /^Node \d+ ran out of energy at (\d+)/) {
	$simlen = $1 if !$simlen || $simlen > $1;
    } elsif ($line =~ /^Node \[(\d+)\] spent energy: (\d+)/) {
	if ($1 != 0) {
	    $avg_energy += $2;
	    $node_num++;
	    if ($2 > $max_energy) { $max_energy = $2; }
	}
    }
}

if ($print_result) { print $result; }
if (%$stat) { print_stat(); } elsif (!$print_result) { print $result; }

sub add_stat {
    my $desc = shift;
    my $k = shift;
    my $v = shift;
    my $total = shift;
    my $s = $stat->{$desc};
    if (!$s) {
        $s = $stat->{$desc} = { total => {}, good => {}, total_sum => 0, good_sum => 0 };
    }
    if ($total) {
	$s->{total}->{$k} += $v;
	$s->{total_sum} += $v;
    } else {
	$s->{good}->{$k} += $v;
	$s->{good_sum} += $v;
    }
}

sub print_stat {
    for my $k (sort keys %$stat) {
	my $s = $stat->{$k};
	my $c = 0;
	if ($s->{total_sum} != 0 && $s->{good_sum} != 0) {
	    my $p = [];
	    for (keys %{$s->{total}}) {
		next unless $s->{total}->{$_};
		push @$p, ($s->{good}->{$_} || 0)*100/$s->{total}->{$_};
	    }
	    $c = confidence($p) if @$p > 1;
	}
	$c = $c ? sprintf("[%.2f%] ",$c) : "";
	printf "$k %.2f% $c$s->{good_sum}/$s->{total_sum}\n", $s->{total_sum} > 0 ? $s->{good_sum}*100/$s->{total_sum} : 0, $c;
    }
    if ($simlen) {
	my $days = $simlen/86400;
	my $h = int($simlen/3600);
	$simlen -= $h*3600;
	my $m = int($simlen/60);
	$simlen -= $m*60;
	printf "First node ran out of energy at %.2d:%.2d:%.2d, (%.2f days)\n",$h,$m,$simlen,$days;
    } elsif ($node_num) {
	$max_energy = $max_energy/$time;
	$avg_energy = ($avg_energy/$node_num)/$time;
	my $energyPerDay = $max_energy*60*60*24;
	printf "Maximum energy consumption at a single node was %.4f J/second, or %.0f J/day\n", $max_energy, $energyPerDay;
	$energyPerDay = $avg_energy*60*60*24;
	printf "Average energy consumption at a single node was %.4f J/second, or %.0f J/day\n", $avg_energy, $energyPerDay;
    }
}

sub confidence {
    my $a = shift;
    return 0 unless @$a;
    my $mean = shift || mean($a);
    my $sqmean = 0;
    for (@$a) { $sqmean += ($mean-$_)*($mean-$_); }
    my $std = sqrt($sqmean/@$a)/sqrt(@$a-1);
    my $c = Z_CONFIDENCE*$std/sqrt(@$a);
#    print "@$a\n ==> M:$mean S:$std C:$c\n";
    return $c;
}

sub mean {
    my $a = shift;
    return 0 unless @$a;
    my $sum = 0;
    for (@$a) { $sum+=$_; }
    return $sum/@$a;
}